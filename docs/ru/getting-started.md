# Начало Работы

В центре любого Vuex-приложения находится **хранилище**. "Хранилище" — это, упрощённо говоря, контейнер, хранящий **состояние** вашего приложения. Две вещи отличают хранилище Vuex от простого глобального объекта:

1. Хранилища Vuex реактивны. Если компоненты Vue зависят от их состояния, изменения состояния хранилища будут провоцировать соответствующие изменения компонентов.

2. Непосредственное изменение состояния хранилища запрещено. Единственная возможность для внесения изменений — явный **вызов мутаций**. Этот подход позволяет быть уверенным, что каждое изменение оставляет в системе след, и даёт возможность использовать инструменты, позволяющие лучше понять работу приложений.

### Простейшее Хранилище

> **ВНИМАНИЕ:** Мы будем использовать синтаксис ES2015 для примеров кода на всём протяжении этой документации. Если вы с ним ещё не разобрались, [сейчас самое время](https://babeljs.io/docs/learn-es2015/)!

После [установки](installation.md) Vuex, давайте создадим хранилище. Всё довольно прямолинейно: нужно просто указать исходное состояние и какие-нибудь мутации:

``` js
// Удостоверьтесь, что вызвали Vue.use(Vuex) в коде ранее, если используете модульный сборщик

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  }
})
```

Теперь мы можем получить доступ к объекту состояния посредством `store.state`, или вызвать изменение состояния методом `store.commit`:

``` js
store.commit('increment')

console.log(store.state.count) // -> 1
```

Ещё раз заметим, что причина, по которой мы вызываем мутацию вместо того чтобы напрямую изменить `store.state.count` заключается в том, что мы хотим явным образом отслеживать изменения. Простое архитектурное соглашение делает наши намерения более очевидными, что позволяет упростить размышления об изменениях состояния приложения при чтении кода. Кроме того, этот подход позволяет реализовать инструменты, способные логировать каждую мутацию, делать моментальные слепки состояния приложения, и даже использовать "путешествия во времени" при отладке.

Использование состояния хранилища в компонентах, из-за реактивной природы хранилища, требует исключительно создания вычисляемых свойств. Изменения состояния можно вызывать инициализируя мутации в методах компонентов.

Вот пример [простейшего приложения Vuex, реализующего счётчик](https://jsfiddle.net/yyx990803/n9jmu5v7/).

Далее мы более подробно обсудим каждую из основных концепций, начиная с [Состояния](state.md)
